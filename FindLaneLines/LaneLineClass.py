import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import numpy as np
import cv2
import math
import os

from moviepy.editor import VideoFileClip
from IPython.display import HTML

class laneline:

	def __init__(self, videofile, outputfilename):
		self.hough_line = None
		self.output = outputfilename
		self.clip = VideoFileClip(videofile)
		self.process_clip = self.clip.fl_image(self.process_image) #NOTE: this function expects color images!!
		self.process_clip.write_videofile(self.output, audio=False)

	def grayscale(self, img):
		return cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)
	
	def BGRtoHSV(self, img):
		return cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

	def canny(self, img, low_threshold, high_threshold):
		return cv2.Canny(img, low_threshold, high_threshold)

	def gaussian_blur(self, img, kernel_size):
		return cv2.GaussianBlur(img, (kernel_size, kernel_size), 0)

	def region_of_interest(self, img, vertices):
		mask = np.zeros_like(img)   
	
		if len(img.shape) > 2:
			channel_count = img.shape[2] 
			ignore_mask_color = (255,) * channel_count
		else:
			ignore_mask_color = 255
 
		cv2.fillPoly(mask, vertices, ignore_mask_color)
	
		masked_image = cv2.bitwise_and(img, mask)
		return masked_image

	def draw_lines(self, img, lines, color=[255, 0, 0], thickness=2):
		for line in lines:
			for x1,y1,x2,y2 in line:
				cv2.line(img, (x1, y1), (x2, y2), color, thickness)

	def hough_lines(self, img, rho, theta, threshold, min_line_len, max_line_gap):
		lines = cv2.HoughLinesP(img, rho, theta, threshold, np.array([]), minLineLength=min_line_len, maxLineGap=max_line_gap)
		self.hough_line = lines
		line_img = np.zeros((img.shape[0], img.shape[1], 3), dtype=np.uint8)
		self.draw_lines(line_img, lines)
		return line_img

	def weighted_img(self, img, initial_img, a=0.8, b=1., c=0.):
		return cv2.addWeighted(initial_img, a, img, b, c)

	def average_lines(self, lines, y_shape):
		#containers for slopes and coordinates of detected hough lines
		x = {"right": [], "left": []}
		y = {"right": [], "left": []}
		slopes = {"right": [], "left": []}

		#Sorting out lines as right and left
		for line in lines:
			x_coord = (line[0,0], line[0,2])
			y_coord = (line[0,1], line[0,3])

			#avoiding NaN scenario
			if (x_coord[0] - x_coord[1])==0:
				pass

			else:
				slope = float(y_coord[1]-y_coord[0]) / float(x_coord[1]-x_coord[0])
				if (0.4 < slope < 0.7):
					slopes["right"].append(slope)
					x["right"].extend([x_coord[0], x_coord[1]])
					y["right"].extend([y_coord[0], y_coord[1]])

				if (-1.0 < slope < -0.6):
					slopes["left"].append(slope)
					x["left"].extend([x_coord[0], x_coord[1]])
					y["left"].extend([y_coord[0], y_coord[1]])

				else:
					pass

		#Finding mean slopes for right and left lane lines            
		mean_slopes = {"right" : np.mean(slopes["right"]), "left": np.mean(slopes["left"])}
		
		#Finding coordinates to draw solid lines in ROI
		x2_right = np.amin(x["right"])
		y2_right = np.amin(y["right"])
		y1_right = y_shape
		x1_right = int(x2_right-(y2_right - y1_right)/mean_slopes["right"])

		#Finding coordinates to draw solid lines in ROI
		x2_left = np.amax(x["left"])
		y2_left = np.amin(y["left"])
		y1_left = y_shape
		x1_left = int(x2_left-(y2_left - y1_left)/mean_slopes["left"])
			
		return [[x1_right, y1_right, x2_right, y2_right],[x1_left, y1_left, x2_left, y2_left]]
		
	#Custom draw line function for drawing solidlines
	def draw_lines_cus(self, img, lines, color=[255, 255, 255], thickness=5):
		for line in lines:
				cv2.line(img, (line[0], line[1]), (line[2], line[3]), color, thickness)

	def process_image(self, image):
		image_blur =  self.gaussian_blur(image,3) 	#Gaussian Blurring
		image_gray = self.grayscale(image_blur) #Conversion to Grayscale
		vertices = np.array([[(125, 539),(440,325),(535,325),(890,539)]]) #Vertices determined for internal and external polygonal masking
		#vertices_neg = np.array([[(200, 539),(470,325),(490,325),(820,539)]])
		image_roi = self.region_of_interest(image_gray,vertices) #Determining Region of Interest of gray image
		image_canny = self.canny(image_gray, 100,200) 	#Using Canny Edge Detector
		image_roi = self.region_of_interest(image_canny,vertices) #Determining Region of Interest
		image_hough = self.hough_lines(image_roi,1,np.pi/180,10,10,10) #Finding Hough Lines
		pre_final_image = self.weighted_img(image_hough,image,.8,1,0) #Merging images
		line_img = np.zeros((image.shape[0], image.shape[1], 3), dtype=np.uint8) #Null image to draw lines and drawing lines
		self.draw_lines_cus(line_img, self.average_lines(self.hough_line,image.shape[0]), color=[255, 0, 0], thickness=10)
		final_image = self.weighted_img(line_img,image,1,.5,0) #Final image generated by adding weighted null and original image
		return final_image

if __name__ == "__main__":
	processed_video = laneline("solidWhiteRight.mp4", 'white.mp4')
	processed_video = laneline("solidYellowLeft.mp4", 'yellow.mp4')
